# 入门篇

## 如何抓住重点，系统高效地学习数据结构与算法？

> 20 个最常用的、最基础数据结构与算法。

10 个数据结构：

- 数组
- 链表
- 栈
- 队列
- 散列表
- 二叉树
- 堆
- 跳表
- 图
- Trie 树

10 个算法：

- 递归
- 排序
- 二分查找
- 搜索
- 哈希算法
- 贪心算法
- 分治算法
- 回溯算法
- 动态规划
- 字符串匹配算法

## 复杂度分析：如何分析、统计算法的执行效率和资源消耗？

### 大 O 复杂度表示法

$$T_{(n)}=O(f_{(n)})$$

其中，`T(n)` 表示代码执行的时间；`n` 表示数据规模的大小；`f(n)` 表示每行代码执行的次数总和。因为这是一个公式，所以用 `f(n)` 来表示。公式中的 `O`，表示代码的执行时间 `T(n)` 与 `f(n)` 表达式成正比。

```c
// case 01
int cal(int n) {
 int sum = 0;
 int i = 1;
 for (; i <= n; ++i) {
   sum = sum + i;
 }
 return sum;
}

// case 02
int cal(int n) {
 int sum = 0;
 int i = 1;
 int j = 1;
 for (; i <= n; ++i) {
   j = 1;
   for (; j <= n; ++j) {
     sum = sum +  i * j;
   }
 }
}
```

所以，第一个例子中的 $T_{(n)}=O_{(2n+2)}$，第二个例子中的 $T_{(n)}=O_{(2n^2+2n+3)}$。这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作 **渐进时间复杂度**（asymptotic time complexity），简称 **时间复杂度**。

当 `n` 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$T_{(n)}=O_{(n)}$；$T_{(n)}=O_{(n^2)}$。

## 时间复杂度分析

我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 `n` 的量级，就是整段要分析代码的时间复杂度。

```c
int cal(int n) {
 int sum = 0;
 int i = 1;
 for (; i <= n; ++i) {
   sum = sum + i;
 }
 return sum;
}
```

其中第 2、3 行代码都是常量级的执行时间，与 `n` 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 `n` 次，所以总的时间复杂度就是 $O_{(n)}$。

## 几种常见时间复杂度实例分析

- 多项式量级
  - 常量阶 $O_{(1)}$
  - 对数阶 $O_{(\log{n})}$
  - 线性阶 $O_{(n)}$
  - 线性对数阶 $O_{(n\log{n})}$
  - 幂阶 $O_{(n^k)}$
>
- 非多项式量级
  - 指数阶 $O_{(k^n)}$
  - 阶乘阶 $O_{(n!)}$

我们把时间复杂度为非多项式量级的算法问题叫作 **NP**（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。

### 1.$O_{(1)}$

```c
int i = 8;
int j = 6;
int sum = i + j;
```

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 $O_{(1)}$。

### 2.$O_{(\log{n})}$、$O_{(n\log{n})}$

```c
i=1;
while (i <= n)  {
 i = i * 2;
}


i=1;
while (i <= n)  {
 i = i * 3;
}
```

我们知道，对数之间是可以互相转换的，$$O_{(\log_3{n})} = O_{(\log_3{2})} * O_{(\log_2{n})}$$，所以 $$O_{(\log_3{n})} = O_{(C*\log_2{n})}$$，其中 $C=\log_3{2}$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数。所以，$O_{(\log_2{n})}$ 就等于 $O_{(\log_3{n})}$。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 $O_{(\log{n})}$。

如果理解了我前面讲的 $O_{(\log{n})}$，那 $O_{(n\log{n})}$ 就很容易理解了。

> $O_{(n\log{n})}$ 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序。

### 3.$O_{(m+n)}$、$O_{(m*n)}$

```c
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

从代码中可以看出，`m` 和 `n` 是表示两个数据规模。我们无法事先评估 `m` 和 `n` 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 $O_{(m+n)}$。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：$T_1{(m)} + T_2{(n)} = O_{(f(m) + g(n))}$。但是乘法法则继续有效：$T_1{(m)} * T_2{(n)} = O_{(f(m) * g(n))}$。

## 空间复杂度分析

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是 **渐进空间复杂度**（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

```c
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 `i`，但是它是常量阶的，跟数据规模 `n` 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 `n` 的 `int` 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 $O_{(n)}$。

我们常见的空间复杂度就是 $O_{(1)}$、$O_{(n)}$、$O_{(n^2)}$，像 $O_{(\log{n})}$、$O_{(n\log{n})}$ 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。
